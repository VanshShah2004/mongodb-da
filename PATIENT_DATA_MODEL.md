1. Patient Data Model Design

1.1 Schema Definition

const mongoose = require("mongoose");

const patientSchema = new mongoose.Schema({
  name: String,
  age: Number,
  gender: String,
  phone: String,
  email: String,
  address: String,
  medicalHistory: [
    {
      condition: String,
      diagnosedOn: Date,
      notes: String
    }
  ]
}, { timestamps: true });

module.exports = mongoose.model("Patient", patientSchema);

---

1.2 Data Model Diagram

Patient Document (MongoDB Collection)
├── _id: ObjectId                    [Auto-generated by MongoDB]
├── name: String                     [Patient's full name]
├── age: Number                      [Patient's age]
├── gender: String                   [male/female/other]
├── phone: String                    [Contact number]
├── email: String                    [Email address]
├── address: String                  [Physical address]
├── medicalHistory: Array            [EMBEDDED DOCUMENTS]
│   └── [Medical History Entry]
│       ├── condition: String        [Disease/condition name]
│       ├── diagnosedOn: Date        [Diagnosis date]
│       └── notes: String            [Additional notes]
├── createdAt: Date                  [Auto-generated timestamp]
├── updatedAt: Date                  [Auto-generated timestamp]
└── __v: Number                      [Version key for optimistic concurrency]

---

1.3 Field-by-Field Explanation

1.3.1 Core Patient Information

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `name` | String | Patient's full name | "Arjun Kumar" |
| `age` | Number | Patient's age | 35 |
| `gender` | String | Patient's gender | "male", "female", "other" |
| `phone` | String | Contact phone number | "9999999999" |
| `email` | String | Email address | "a@demo.com" |
| `address` | String | Physical address | "Delhi" |

1.3.2 Embedded Medical History (NoSQL Feature: Embedding)

| Field | Type | Description | Example |
|-------|------|-------------|---------|
| `medicalHistory` | Array | Array of medical history documents | See below |
| `medicalHistory[].condition` | String | Name of medical condition | "Diabetes" |
| `medicalHistory[].diagnosedOn` | Date | Date when condition was diagnosed | "2020-01-15" |
| `medicalHistory[].notes` | String | Additional notes about the condition | "Type 2, controlled with medication" |

1.3.3 Auto-Generated Fields

| Field | Type | Description | Auto-Generated |
|-------|------|-------------|----------------|
| `_id` | ObjectId | Unique document identifier | By MongoDB |
| `createdAt` | Date | Document creation timestamp | By Mongoose (timestamps: true) |
| `updatedAt` | Date | Document last update timestamp | By Mongoose (timestamps: true) |
| `__v` | Number | Version key | By Mongoose |

---

1.4 Example Document in MongoDB

{
  "_id": "6908617a3441e175d71a9d31",
  "name": "Arjun Kumar",
  "age": 35,
  "gender": "male",
  "phone": "9999999999",
  "email": "a@demo.com",
  "address": "Delhi",
  "medicalHistory": [
    {
      "condition": "Diabetes",
      "diagnosedOn": "2020-01-15T00:00:00.000Z",
      "notes": "Type 2, controlled with medication"
    },
    {
      "condition": "Hypertension",
      "diagnosedOn": "2019-06-20T00:00:00.000Z",
      "notes": "Mild, monitoring required"
    }
  ],
  "createdAt": "2025-11-03T08:02:02.690Z",
  "updatedAt": "2025-11-03T08:02:02.690Z",
  "__v": 0
}

---

1.5 NoSQL Design Patterns Used

1.5.1 Embedding (Embedded Documents)
- Feature: `medicalHistory` is an embedded array within the patient document
- Structure: Each entry in the array is a sub-document with its own fields
- Advantage:
  - Fast single-document reads (no joins needed)
  - All patient data retrieved in one query
  - Atomic updates to patient + history together
  - Perfect for one-to-few relationships

Example:
// When you fetch a patient, you get everything in one query:
const patient = await Patient.findById(id);
// patient.medicalHistory contains all history entries - no separate query needed!

1.5.2 Flexible Schema
- Feature: Schema allows optional fields and varying structures
- Advantage:
  - No strict validation - fields can be missing
  - Can add new fields without migration
  - Different patients can have different fields
  - Easy to evolve schema over time

Example:
// Patient 1: Minimal info
{ name: "John", age: 25 }

// Patient 2: Full info + extra fields
{
  name: "Jane",
  age: 30,
  gender: "female",
  phone: "1234567890",
  email: "jane@email.com",
  address: "Mumbai",
  medicalHistory: [...],
  emergencyContact: "9876543210",  // Extra field not in schema!
  bloodGroup: "O+"                  // Another extra field!
}

1.5.3 Timestamps Auto-Management
- Feature: `{ timestamps: true }` automatically manages `createdAt` and `updatedAt`
- Advantage:
  - No manual date tracking needed
  - Automatic audit trail
  - Always know when document was created/modified

---

1.6 Comparison: Embedding vs Referencing

1.6.1 Current Design: EMBEDDING (medicalHistory)
Patient Document
└── medicalHistory: [
      { condition: "Diabetes", ... },
      { condition: "Hypertension", ... }
    ]

When to use Embedding:
- One-to-few relationship (few history entries per patient)
- Data is frequently accessed together
- Data doesn't need to be shared across documents
- Small sub-documents

1.6.2 Alternative: REFERENCING (if we stored history separately)
Patient Document
└── medicalHistoryIds: [ObjectId1, ObjectId2]

MedicalHistory Collection
├── { _id: ObjectId1, patientId: ObjectId, condition: "Diabetes" }
└── { _id: ObjectId2, patientId: ObjectId, condition: "Hypertension" }

When to use Referencing:
- One-to-many relationship (thousands of entries)
- Data is shared across documents
- Large sub-documents
- Need to query sub-documents independently

For medical history, EMBEDDING is the right choice because:
- Patients typically have few history entries (< 50)
- History is specific to each patient
- We always fetch patient with their history together

---

1.7 MongoDB Collection Structure

Collection Name: `patients` (automatically pluralized by Mongoose from model name "Patient")

Indexes: Can be created for faster queries:
// Example indexes you might want:
db.patients.createIndex({ name: 1 })           // Fast name searches
db.patients.createIndex({ email: 1 }, { unique: true })  // Unique email
db.patients.createIndex({ "medicalHistory.condition": 1 })  // Search conditions

---

1.8 Key Design Decisions

1. Why Array for medicalHistory?
   - Patients can have multiple medical conditions
   - Array preserves order and allows easy addition/removal
   - Embedded documents avoid joins

2. Why String for phone/email?
   - Flexibility - different formats allowed
   - Validation can be added later if needed
   - Simpler than strict regex validation in schema

3. Why timestamps: true?
   - Audit trail important for medical records
   - Automatic tracking saves development time
   - Standard practice for database records

4. Why flexible schema (no required fields)?
   - Allows gradual data entry
   - Different use cases (some patients might not have all info)
   - NoSQL philosophy: flexible over strict

---

1.9 Schema Enhancements (Optional)

If you want to add validation later:

const patientSchema = new mongoose.Schema({
  name: { type: String, required: true },
  age: { type: Number, min: 0, max: 150 },
  gender: { type: String, enum: ["male", "female", "other"] },
  phone: { type: String, match: /^[0-9]{10}$/ },
  email: { type: String, lowercase: true, trim: true },
  address: String,
  medicalHistory: [{
    condition: { type: String, required: true },
    diagnosedOn: { type: Date, default: Date.now },
    notes: String
  }]
}, { timestamps: true });

---

1.10 Visual Representation

┌─────────────────────────────────────────────────┐
│          Patient Collection (patients)          │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────────────────────────────────┐  │
│  │ Patient Document 1                       │  │
│  │ ┌────────────────────────────────────┐   │  │
│  │ │ _id: ObjectId("...")               │   │  │
│  │ │ name: "Arjun Kumar"                 │   │  │
│  │ │ age: 35                             │   │  │
│  │ │ gender: "male"                      │   │  │
│  │ │ phone: "9999999999"                 │   │  │
│  │ │ email: "a@demo.com"                  │   │  │
│  │ │ address: "Delhi"                    │   │  │
│  │ │                                     │   │  │
│  │ │ medicalHistory: [                    │   │  │
│  │ │   ┌──────────────────────────┐      │   │  │
│  │ │   │ condition: "Diabetes"    │      │   │  │
│  │ │   │ diagnosedOn: 2020-01-15  │      │   │  │
│  │ │   │ notes: "Type 2"          │      │   │  │
│  │ │   └──────────────────────────┘      │   │  │
│  │ │   ┌──────────────────────────┐      │   │  │
│  │ │   │ condition: "Hypertension"│      │   │  │
│  │ │   │ diagnosedOn: 2019-06-20  │      │   │  │
│  │ │   │ notes: "Mild"            │      │   │  │
│  │ │   └──────────────────────────┘      │   │  │
│  │ │ ]                                    │   │  │
│  │ │                                     │   │  │
│  │ │ createdAt: 2025-11-03T08:02:02Z    │   │  │
│  │ │ updatedAt: 2025-11-03T08:02:02Z    │   │  │
│  │ └────────────────────────────────────┘   │  │
│  │                                            │  │
│  │  ┌────────────────────────────────────┐   │  │
│  │  │ Patient Document 2                 │   │  │
│  │  │ (Different structure - Flexible!)  │   │  │
│  │  └────────────────────────────────────┘   │  │
│  │                                            │  │
│  │  ... more documents ...                    │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
└─────────────────────────────────────────────────┘

---

1.11 Summary for Report

For your report Section 3 (Data Model), you can say:

"The Patient model uses an embedded document pattern for medical history, storing medical conditions as an array of sub-documents within each patient document. This design enables fast single-query retrieval of all patient data including medical history, eliminates the need for joins, and provides a flexible schema that can accommodate varying patient information structures. The schema includes automatic timestamps for audit trails and leverages MongoDB's document-oriented structure for natural data modeling."

---

This data model demonstrates key NoSQL principles: flexibility, embedding for performance, and schema evolution without migrations.
